from lab_8.ex_3 import Graph


def walk(G, path=[]):
    # если граф пустой, то делать ничего не нужно, завершаем рекурсию
    if G.vertices == []:
        return

    # если путь пустой, то добавляем в него первую в лексикографическом порядке вершину графа
    if path == []:
        path.append(G.vertices()[0])

    # С помощью outgoing() пытаемся найти ребро из последней в пути path вершины.
    # Если нашли, модифицируем метку, добавляем новую вершину в path и делаем рекурсивный вызов.
    # Не забудьте, что функция walk должна вернуть путь!
    for out_ver in G.outgoing(path[-1]):
        if G[out_ver] != 0:
            G[out_ver] -= 1
            path.append(out_ver[1])
            return walk(G, path)

    # если свободных ребер нет, то просто возвращаем path
    return path

if __name__ == '__main__':
    # Этот код менять не нужно. При корректной реализации класса Graph он должен выдать корректный результат
    # Раскомментируйте этот код, когда перестанете получать сообщения об ошибках

    g = Graph([1, 2, 3], [(1, 2), (2, 3), (3, 1)])
    g[(1, 2)] = 1
    g[(2, 3)] = 1
    g[(3, 1)] = 0
    print(walk(g, [1]))
    print(g[(1, 2)])
    print(g[(2, 3)])